# Список свойств

Ниже идёт список всех свойств (properties) из стандартной библиотеки.

* **n_to**, **s_to**, **e_to**, **w_to**…

  Только для комнат. Также есть **ne_to**, **nw_to**, **se_to**, **sw_to**, **in_to**, **out_to**, **u_to** и **d_to**.

  Соответственно это направления на север, юг, восток, запад, СВ, СЗ, ЮВ, ЮЗ, внутрь, наружу, вверх и вниз.

  Значением свойства может быть: 
  * `false` (по умолчанию), что означает что выхода нет;
  * строка, которая пояснит игроку, почему выхода в этом направлении нет;
  * комната, либо дверь, в которую будет вести выбранное направление из текущей комнаты;
  * процедура, которая вернёт что-либо из выше перечисленного.

  ```
  Object At_Top_Of_Small_Pit "Над колодцем"
  with description
  "Прямо из ваших ног находится колодец, буквально дышащий белым туманом.
   В этом месте проход на запад кончается, если не считать очень узкую трещину.^
   Грубые каменные ступени дают возможность спуститься вниз.",
       e_to In_Bird_Chamber,
       w_to "Трещина слишком узка, чтобы в нее протиснуться.",
       d_to
       [; if (large_gold_nugget in player)
          {   deadflag=1;
              "Вы достигли дна колодца быстрее, чем сами хотели,
               и лежите там со сломанной шеей.";
          }
          return In_Hall_Of_Mists;
       ],
  ...
  ```

* **add_to_scope**

  Если текущий объект находится в области видимости (scope), то все объекты, перечисленные в этом свойстве, тоже попадут в область видимости. Если делать это через процедуру, то она должна вызвать `PlaceInScope(объект)`, чтобы поместить `объект` в область видимости.

* **article** и **articles**

  Артикли для объектов. В русской версии не требуются. 

* **after**
 
  Сюда попадают все действия *после того*, как они произошли, но ещё до того, как об этом было сказано игроку.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, выполнение продолжится, и выведется текст о том, что произошло. Если `true`, то выполнение на этом остановится, текста выведено не будет.

  Так можно заменить текст стандартных реакций на свой:

  ```
  Object -> RustyDoor "ржав/ая железн/ая двер/ь"
  with name 'больш' 'ржав' 'железн' 'двер' 'петл',
      ...
      after
      [; 
          Open: "Дверь отворилась с жутким скрипом и дождем из осыпающейся ржавчины.";
      ],
  has static door locked female;
  ```

  Или, например, сделать что-то дополнительное к действию:

  ```
  Object top_of_tree "На верхушке дерева"
  with description "На этой высоте цепляться за ствол уже не так удобно.",
      d_to clearing,
      after [;
          Drop:
              move noun to clearing;
              return false;
      ],
  has light;
  ```

* **before**

  Сюда попадают все действия после ввода команды, но ещё *до того*, как они произошли.

  Так можно перехватить действие и объяснить игроку, почему оно невозможно, или выполнить какую-то другую логику.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, то выполнение продолжится. Если `true`, то выполнение на этом остановится (действие не произойдёт).

  ```
  Treasure -> "персидск/ий ков/е/р/"
  with name 'персидск' 'ковер' 'ковр',
       before
       [; Take: if (Dragon in location)
                "То, что на ковре развалился здоровенный (и весьма свирепый) дракон,
                 немного мешает реализации этой привлекательной идеи.";
       ],
  ...
  ```

* **cant_go**

  Свойство для комнаты, содержащее строку, либо процедуру, которая выведет строку при попытке пойти в несуществующем направлении. По умолчанию: «Этот путь недоступен».

  ```
  Object before_cottage "Перед домом"
      with description
              "Ты стоишь около избушки, на восток от которой раскинулся лес.",
          e_to forest,
          cant_go "Единственный путь ведет на восток.",
      has light;
  ```

* **capacity**

  Для `container` или `supporter`-объектов — максимальное количество объектов, которые в или на объект можно поместить. По умолчанию — 100. Для игрока — максимальное количество объектов, которое можно удержать. Для изначального игрока (`selfobj`) это значение выставляется через `MAX_CARRIED`.

* **daemon**

  После активации через `StartDaemon(объект)`, эта процедура будет вызываться один раз каждый ход до тех пор, пока не будет остановлена через `StopDaemon(объект)`.

  Это хорошо подходит для моделирования NPC, автономных систем, механизмов и т.д.

  ```
  Object -> Bear "огромн/ый пещерн/ый медвед/ь"
  with ...,
      daemon [; 
          if (location==thedark) rfalse;
          if (self in location) {
              if (location==At_Breath_Taking_View)
                  "^Медведь у Вас за спиной восторженно взревел!";
              rfalse;
          }
          move self to location;
          "^Медведь неотступно следует за Вами.";
      ],
  ...
  ```

* **description**

  Для объекта: описание объекта, которое выводится при осмотре объекта игроком.

  Для комнаты: описание комнаты.

  Описание может быть строкой или сгеренировано процедурой.

  ```
  Object  hook "маленьк/ий бронзов/ый крюч/о/к/" cloakroom
  with  name 'маленьк' 'бронзов' 'крюк' 'крючок' 'крючк' 'вешалк',
  ...
  description [;
      print "Всего лишь маленький бронзовый крючок для одежды, ";
      if (self == parent(cloak)) "с которого свисает черный бархатный плащ.";
      "привинченный к стене.";
  ],
  has scenery supporter male;
  ```