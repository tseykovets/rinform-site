# Список свойств

Ниже идёт (пока неполный) список свойств (properties) из стандартной библиотеки.

* **n_to**, **s_to**, **e_to**, **w_to**…

  Только для комнат. Также есть **ne_to**, **nw_to**, **se_to**, **sw_to**, **in_to**, **out_to**, **u_to** и **d_to**.

  Соответственно это направления на север, юг, восток, запад, СВ, СЗ, ЮВ, ЮЗ, внутрь, наружу, вверх и вниз.

  Значением свойства может быть: 
  * `false` (по умолчанию), что означает что выхода нет;
  * строка, которая пояснит игроку, почему выхода в этом направлении нет;
  * комната, либо дверь, в которую будет вести выбранное направление из текущей комнаты;
  * процедура, которая вернёт что-либо из выше перечисленного.

  ```
  Object At_Top_Of_Small_Pit "Над колодцем"
  with description
  "Прямо из ваших ног находится колодец, буквально дышащий белым туманом.
   В этом месте проход на запад кончается, если не считать очень узкую трещину.^
   Грубые каменные ступени дают возможность спуститься вниз.",
       e_to In_Bird_Chamber,
       w_to "Трещина слишком узка, чтобы в нее протиснуться.",
       d_to
       [; if (large_gold_nugget in player)
          {   deadflag=1;
              "Вы достигли дна колодца быстрее, чем сами хотели,
               и лежите там со сломанной шеей.";
          }
          return In_Hall_Of_Mists;
       ],
  ...
  ```

* **add_to_scope**

  Если текущий объект находится в области видимости (scope), то все объекты, перечисленные в этом свойстве, тоже попадут в область видимости. Если делать это через процедуру, то она должна вызвать `PlaceInScope(объект)`, чтобы поместить `объект` в область видимости.

* **article** и **articles**

  Артикли для объектов. В русской версии не требуются. 

* **after**
 
  Сюда попадают все действия *после того*, как они произошли, но ещё до того, как об этом было сказано игроку.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, выполнение продолжится, и выведется текст о том, что произошло. Если `true`, то выполнение на этом остановится, текста выведено не будет.

  Так можно заменить текст стандартных реакций на свой:

  ```
  Object -> RustyDoor "ржав/ая железн/ая двер/ь"
  with name 'больш' 'ржав' 'железн' 'двер' 'петл',
      ...
      after
      [; 
          Open: "Дверь отворилась с жутким скрипом и дождем из осыпающейся ржавчины.";
      ],
  has static door locked female;
  ```

  Или, например, сделать что-то дополнительное к действию:

  ```
  Object top_of_tree "На верхушке дерева"
  with description "На этой высоте цепляться за ствол уже не так удобно.",
      d_to clearing,
      after [;
          Drop:
              move noun to clearing;
              return false;
      ],
  has light;
  ```

* **before**

  Сюда попадают все действия после ввода команды, но ещё *до того*, как они произошли.

  Так можно перехватить действие и объяснить игроку, почему оно невозможно, или выполнить какую-то другую логику.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, то выполнение продолжится. Если `true`, то выполнение на этом остановится (действие не произойдёт).

  ```
  Treasure -> "персидск/ий ков/е/р/"
  with name 'персидск' 'ковер' 'ковр',
       before
       [; Take: if (Dragon in location)
                "То, что на ковре развалился здоровенный (и весьма свирепый) дракон,
                 немного мешает реализации этой привлекательной идеи.";
       ],
  ...
  ```

* **cant_go**

  Свойство для комнаты, содержащее строку, либо процедуру, которая выведет строку при попытке пойти в несуществующем направлении. По умолчанию: «Этот путь недоступен».

  ```
  Object before_cottage "Перед домом"
      with description
              "Ты стоишь около избушки, на восток от которой раскинулся лес.",
          e_to forest,
          cant_go "Единственный путь ведет на восток.",
      has light;
  ```

* **capacity**

  Для `container` или `supporter`-объектов — максимальное количество объектов, которые в или на объект можно поместить. По умолчанию — 100. Для игрока — максимальное количество объектов, которое можно удержать. Для изначального игрока (`selfobj`) это значение выставляется через `MAX_CARRIED`.

* **daemon**

  После активации через `StartDaemon(объект)`, эта процедура будет вызываться один раз каждый ход до тех пор, пока не будет остановлена через `StopDaemon(объект)`.

  Это хорошо подходит для моделирования NPC, автономных систем, механизмов и т.д.

  ```
  Object -> Bear "огромн/ый пещерн/ый медвед/ь"
  with ...,
      daemon [; 
          if (location==thedark) rfalse;
          if (self in location) {
              if (location==At_Breath_Taking_View)
                  "^Медведь у Вас за спиной восторженно взревел!";
              rfalse;
          }
          move self to location;
          "^Медведь неотступно следует за Вами.";
      ],
  ...
  ```

* **describe**

  Вызывается перед тем, как объект будет выведен в комнате. Если это свойство задано у комнаты, то вызывается перед выводом описания комнаты.

  Если `describe` вернёт:
  * `false`, то выполнение продолжится, и выведется стандартное описание.
  * `true`, то на этом выполнение остановится, дальнейшего вывода текста не будет.

  ```
  Treasure -> "персидск/ий ков/е/р/"
  with name 'персидск' 'ковер' 'ковр',
  ...
  describe [;
      if (Dragon in location)
          "Дракон лежит на роскошном персидском ковре!";
      "Пол пещеры покрыт роскошным персидским ковром.";
  ],
  ...
  ```

* **description**

  Для объекта: описание объекта, которое выводится при осмотре объекта игроком.

  Для комнаты: описание комнаты.

  Описание может быть строкой или может быть сгеренировано процедурой.

  ```
  Object  hook "маленьк/ий бронзов/ый крюч/о/к/" cloakroom
  with  name 'маленьк' 'бронзов' 'крюк' 'крючок' 'крючк' 'вешалк',
  ...
  description [;
      print "Всего лишь маленький бронзовый крючок для одежды, ";
      if (self == parent(cloak)) "с которого свисает черный бархатный плащ.";
      "привинченный к стене.";
  ],
  has scenery supporter male;
  ```

* **door_dir**

  Это свойство должно возвращать направление, в котором ведёт данная дверь. Например, если мост ведёт на восток, то нужно вернуть `e_to`.

  ```
  Object CrystalBridge "хрустальн/ый мост/"
  with name 'волшебн' 'хрустальн' 'мост',
      initial "Оба края пропасти теперь соединяет хрустальный мост.",
      ...
      door_dir [; 
          if (location==West_Side_Of_Fissure) return e_to;
          return w_to;
      ],
      ...
  ```

* **door_to**

  Это свойство должно вернуть, куда (в какую локацию) ведёт дверь.

  Можно вернуть:
  * `false` (по умолчанию), что означает что дверь ведёт никуда;
  * строка, которая пояснит игроку, почему дверь ведёт никуда;
  * объект комнаты, в которую должна вести дверь;
  * процедура, которая вернёт что-либо из выше перечисленного.

  ```
  Object CrystalBridge "хрустальн/ый мост/"
  with name 'волшебн' 'хрустальн' 'мост',
      initial "Оба края пропасти теперь соединяет хрустальный мост.",
      ...
      door_to [;
          if (location==West_Side_Of_Fissure) return On_East_Bank_Of_Fissure;
          return West_Side_Of_Fissure;
      ],
      ...
  ```

* **each_turn**

  Текст или процедура, которые будут выполняться (выводиться) в конце каждого хода (после всех демонов (daemons) и таймеров), если объект находится в зоне видимости.

  ```
  Object branch "надежн/ый толст/ый сук/" top_of_tree
    with ...
        each_turn [; if (bird in nest && nest in branch) deadflag = 2; ],
    ...
  ```

* **found_in**

  Объект будет присутствовать во всех комнатах, перечисленных через пробел в этом свойстве. Если указать не комнату, а обычный объект, то будет присутствовать в той же комнате, что указанный объект.

  Так можно удобно моделировать, например, небо, солнце и любые другие объекты, которые должны присутствовать в нескольких местах.

  Можно написать процедуру, которая будет это решать. Процедуре нужно оценить переменную `location` и вернуть `true`, если объект должен присутствовать, или `false` в противном случае.

  Обратите внимание, что свойство проверяется *только* в момент перехода из одной комнаты в другую. Также, свойство перестаёт работать для объектов с атрибутом `absent`.

  ```
  Prop "Солдат/ы Гесслера"
      with ...,
      found_in south_square mid_square north_square marketplace,
  has animate pluralname;
  ```

* **grammar**

  Только для объектов `animate` или `talkable`. Только для приказов (`> Антон, отдай мне бутерброд`). Вызывается тогда, когда парсер определил глагол (`verb_word`) и положение глагола в команде (`verb_wordnum`) при обращении к кому-то, но ещё не попробовал применить эту грамматику. 

  Необходимо вернуть один из вариантов:
  * `false`, чтобы библиотека продолжила выполнение;
  * `true`, чтобы на этом остановить выполнение и таким образом указать, что ваш код сделал все нужные действия самостоятельно: выставил `action`, `noun`, `second`;
  * словарное слово глагола, например `'бр'` («брать»), чтобы библиотека использовала грамматику этого глагола;
  * или минус с глаголом, `-'бр'`, чтобы библиотека использовала грамматику этого глагола, а затем ещё и стандартную.

* **initial**

  Описание объекта, который ещё не был подобран — то есть изначальное описание в комнате, где он лежит. Это может быть как строка, так и процедура.

  Для комнаты такое свойство вызывается или выводится, когда игрок в неё заходит.

  ```
  Object -> black_rod "черн/ый жезл/ со ржавой звездой на конце"
  with name 'черн' 'ржав' 'жезл' 'звезд',
      initial "Трехфутовый черный жезл, один конец которого украшает 
               ржавая железная звезда, лежит у Ваших ног.",
      description "Черный жезл длиной в три фута, со звездой на конце.",
  ...
  ```

* **inside_description**

  Описание объекта, выводящееся, когда игрок находится внутри него. Такой объект должен иметь атрибут `enterable`.

  ```
  Object -> cage "железн/ая клетк/а"
  with  name 'железн' 'клетк' 'прут' 'решетк' 'знак',
      description
          "Символы на клетке таковы: Птица, Стрела, Вепрь.",
      inside_description [;
          if (self.floor_open)
              "Узкая нора в земляном полу клетки открывает путь вниз,
               в погребальный колодец.";
          "Толстые прутья железной решетки окружают вас со всех сторон.";
          ],
  ...
  has enterable transparent container openable open static female;
  ```

* **invent**

  Это свойство позволяет изменять то, как выводится объект в инвентаре.

  Оно вызывается дважды:
  * сначала никакой текст в инвентаре про этот объект выведен не был, и `inventory_stage` равно **1**.

    Здесь можно удобно и любым способом изменить вывод текста в инвентаре. После чего нужно вернуть `false`, чтобы продолжить, или `true` чтобы на этом закончить.

  * затем выведется короткое (обычное) имя объекта, и будет второй вызов, где `inventory_stage` равно **2**.

    Уточняющие детали вида «(открыт)» или «(пуст)» на этот момент ещё не вывелись, и здесь можно вывести свой текст, например «(висит набекрень)».

    Здесь аналогично нужно вернуть `false`, чтобы продолжить, или `true` чтобы на этом закончить.

  ```
  Object  your_candle "свеч/а"
  ...
  invent [;
      if (sin_shadow.evil == true) {
          if (self.lit == true) {
              print "свеча (горит)"; rtrue;
          }
          else
              print "свеча"; rtrue;
      }
      if (self.lit == true) {
          print "твоя свеча (горит)"; rtrue;
      }
      else
          print "твоя свеча"; rtrue;
    ],
  ...
  ```

* **life**

  Здесь нужно перечислять правила для `animate` объектов. Работают они так же, как `before` или `after`, но только для следующих действий:

  `Attack Kiss WakeOther ThrowAt Give Show Ask Tell Answer Order`

  Если код вернёт `false`, выполнение продолжится, и выведется текст о том, что произошло. Если `true`, то выполнение на этом остановится, текста выведено не будет.

  ```
  Object cecilia1 "девушк/а"
  ...
      life [;
        WakeOther:
            if (self.woken == false)
                "Ты осторожно толкаешь её, но она спит слишком крепко.";
            else
                "Не нужно.";
      ...
  ```