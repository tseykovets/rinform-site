# Синтаксис Информа

## Значения

Значения в Информе бывают следующих типов:

* Численные:
  * Десятичные: `451`
  * Шестнадцатеричные: `$1C3`
  * Двоичные: `$$111000011`
* Действие: `##Look`
* Символ: `'ъ'`
* Словарное слово: `'хлопушк/а'`. Можно использовать как двойные, так и одинарные кавычки.
* Строка, в двойных кавычках: `"Новогодняя хлопушка."`. Есть набор специальных символов, в частности:
  * `^` — перенос строки.
  * `~` — типографские кавычки (**"**). Но в русском языке принято использовать кавычки-ёлочки: **«** и **»**.
  * `@@64` — «cобачка», **@**.
  * `@@92` — обратный слеш, **\\**.
  * `@@94` — карет, **^**.
  * `@@126` — тильда, **~**.


## Имена

Имена есть у констант, переменных, массивов, классов, свойств, объектов, атрибутов, функций и меток.

Имена должны быть на латинице, могут содержать цифры и знак подчёркивания, не могут начинаться с цифры и должны быть длиной не более 32 символов.


## Константы

Константа — это значение, которое не изменяется во время игры. По умолчанию константа равна 0.

> <tt>
Constant <em>имя_константы</em>;<br>
Constant <em>имя_константы</em> = <em>выражение</em>;
</tt>

Есть несколько стандартных констант: `true` (1), `false` (0), `nothing` (0), `NULL` (-1).

## Переменные и массивы

Переменные и массивы могут изменяться в процессе игры, и по умолчанию равны 0.

Глобальные переменные:

> <tt>
Global <em>имя_переменной</em>;<br>
Global <em>имя_переменной</em> = <em>выражение</em>;
</tt>

Массив машинных слов (word). Слово в Glulx — 4 байта, в Z-машине — 2 байта. Элементы массива длиной N доступны через `массив-->0`, `массив-->1`, ... `массив-->(N-1)`.

> <tt>
Array <em>имя_массива</em> ––> <em>N</em>;<br>
Array <em>имя_массива</em> ––> <em>выражение1</em> <em>выражение2</em>... <em>выражениеN</em>;<br>
Array <em>имя_массива</em> ––> "<em>строка</em>";<br>
</tt>

Массив-таблица. Элементы таблицы длиной N доступны через `массив-->1`, `массив-->2`, ... `массив-->N`, при этом `массив-->0` будет равно N.

> <tt>
Array <em>имя_массива</em> table <em>N</em>;<br>
Array <em>имя_массива</em> table <em>выражение1</em> <em>выражение2</em>... <em>выражениеN</em>;<br>
Array <em>имя_массива</em> table "<em>строка</em>";<br>
</tt>

Байтовый массив. Элементы массива длиной N доступны через `массив->0`, `массив->1`, ... `массив->(N-1)`.

> <tt>
Array <em>имя_массива</em> –> <em>N</em>;<br>
Array <em>имя_массива</em> –> <em>выражение1</em> <em>выражение2</em>... <em>выражениеN</em>;<br>
Array <em>имя_массива</em> –> "<em>строка</em>";<br>
</tt>

Массив-строка. Элементы строки длиной N доступны через `массив->1`, `массив->2`, ... `массив->N`, при этом `массив->0` будет равно N.

> <tt>
Array <em>имя_массива</em> string <em>N</em>;<br>
Array <em>имя_массива</em> string <em>выражение1</em> <em>выражение2</em>... <em>выражениеN</em>;<br>
Array <em>имя_массива</em> string "<em>строка</em>";<br>
</tt>

Переменные также есть у объектов (как свойства) и у процедур (локальные переменные).


## Выражения и операторы

Арифметические и логические операции:

* `p + q` сложение,
* `p - q` вычитание,
* `p * q` умножение,
* `p / q` целочисленное деление,
* `p % q` остаток от деления,
* `p++` прибавляет единицу к *p* и возвращает предыдущее значение,
* `++p` прибавляет единицу к *p* и возвращает новое значение,
* `p--` вычитает единицу от *p* и возвращает предыдущее значение,
* `--p` вычитает единицу от *p* и возвращает новое значение,
* `p & q` побитовое И,
* `p | q` побитовое ИЛИ,
* `~p` побитовое НЕ.

Условные выражения возвращают `true` или `false`, в зависимости от того, выполняется ли условие. `q` может быть списком, например `q1 or q2 or... qN`.

* `p == q` p равно q,
* `p ~= q` p не равно q,
* `p > q` p больше q,
* `p < q` p меньше q,
* `p >= q` p больше либо равно q,
* `p <= q` p меньше либо равно q,
* `p ofclass q` объект p является объектом класса q,
* `p in q` объект p является непосредственным дочерним для объекта q,
* `p notin q` объект p не является непосредственным дочерним для объекта q,
* `p provides q` у объекта p есть свойство q,
* `p has q` у объекта p есть атрибут q,
* `p hasnt q` у объекта p нет атрибута q.


* `p && q` возвращает `true` если оба значения `true` (ненулевое),
* `p || q` возвращает `true` если хотя бы одно из значений `true` (ненулевое),
* `~~p` возвращает `true` если p равно `false` (нулю).

Чтобы проверить, является ли объект `q` дочерним для объекта `p` с рекурсией (чтобы проверялись дети детей и т.д.), используйте `IndirectlyContains(p,q)`.

Чтобы найти ближайшего родителя для двух объектов: `CommonAncestor(p,q)`. Если его нет, вернётся `nothing`.

Генератор случайных чисел:
* `random(N)` вернёт случайное число от 1 до N.
* `random(значение, значение, значение...)` вернёт одно из значений случайным образом.


## Классы и объекты

Класс — это шаблон для объектов со схожими свойствами.

> <tt>
Class&nbsp;&nbsp;<em>имя_класса</em>(<em>N</em>)<br>
&nbsp;class <em>класс</em> <em>класс</em>... <em>класс</em><br>
&nbsp;with&nbsp;&nbsp;<em>свойство</em>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>свойство</em>,<br>
&nbsp;has&nbsp;&nbsp;&nbsp;<em>атрибут</em> <em>атрибут</em>... <em>атрибут</em>;<br>
</tt>

`N` необходимо при динамическом создании объектов во время игры и указывает их максимальное количество.

Объект может быть самостоятельным, или наследован от класса или нескольких классов.

> <tt>
Object [->...] <em>имя_объекта</em> "<em>текстовое имя</em>" <em>объект_родитель</em><br>
&nbsp;class <em>класс</em> <em>класс</em>... <em>класс</em><br>
&nbsp;with&nbsp;&nbsp;<em>свойство</em>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>свойство</em>,<br>
&nbsp;has&nbsp;&nbsp;&nbsp;<em>атрибут</em> <em>атрибут</em>... <em>атрибут</em>;<br>
</tt>

Вместо `Object` можно сразу использовать имя класса. Имя объекта, текстовое имя, стрелки и родитель — необязательны. Нельзя использовать одновременно стрелки и `объект_родитель`.

Каждая из секций — `class`, `with` и `has` (а также редко используемая `private`) — опциональна, и они могут идти в любом порядке.

Чтобы определить класс объекта (`Class`, `Object`, `Routine`, `String` или `nothing`), используйте `metaclass(объект)`.


## Работа с деревом объектов

## Обмен сообщениями

## Инструкции

## Процедуры

## Ветвление

## Циклы

## Вывод

## Глаголы и действия

## Полезные директивы
